<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="feed" href="/feeds/all.atom.xml" title="Articles">

    <title>Genome Assembly for Hackers - Tim Head</title>


    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <!-- Bootstrap -->
    <link href="/theme/css/bootstrap.min.css" rel="stylesheet">

    <link href="/theme/css/pygments/default.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-49540142-1', 'betatim.github.io');
      ga('send', 'pageview');
    </script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js" type="text/javascript"></script>

    <!-- <script type="text/javascript" src="/interactive/main-built.js" charset="utf-8"></script>-->
    <script type="text/javascript" src="https://cdn.rawgit.com/oreillymedia/thebe/17fe0971303cac24d7e806c8f1bc8ba3c0c40b23/static/main-built.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.10.0/codemirror.min.css">
    <script>
      $(function(){
	      new Thebe({url:"https://tmpnb.org/",
		      kernel_name: "python3",
		      load_mathjax: false,
		      container_selector: "div.entry-content"});
      });
    </script>

    <!-- extra stuff for nbconvert -->
    <!-- extra stuff for nbconvert -->

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/javascript">
      init_mathjax = function() {
      if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        },
        displayAlign: 'left', // Change this to 'center' to center equations.
        "HTML-CSS": {
          styles: {'.MathJax_Display': {"margin": 0}}
        }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
      }
      }
      init_mathjax();
    </script>

    <link href='https://fonts.googleapis.com/css?family=Roboto:400,400italic,700&subset=latin,latin-ext' rel='stylesheet' type='text/css'>

    <style>
      .cell {
      margin-top: 22px;
      margin-bottom: 11px;
      }
      .text_cell_render {
      padding: 0;
      }
      .title {
      border-left: 7px solid #eee;
      padding: 10px 10px 10px 23px;
      margin-left: -30px;
      }
      .when {
      padding-top: 5px;
      text-transform: uppercase;
      color: #777;
      }
      .entry-content img {
      border-radius: 4px;
      }
      .navbar {
      margin: 75px 0 25px 0;
      }
      .footer {
      margin: 100px 0 25px 0;
      border-top: 1px solid transparent;
      border-color: #eee;
      }
      .powered-by {
      padding: 15px;
      float: right;
      }
      .social {
      padding: 15px;
      float: left;
      }
      .social i {
      padding-left: 15px;
      }
      .social a {
      color: black;
      transition: all 0.25s ease-in;
      -webkit-transition: all 0.25s ease-in;
      }
      .social a:hover {
      text-shadow: 0 0 15px #000;
      }
      .listing span {
      float: right;
      text-transform: uppercase;
      }
      .listing li {
      list-style-type: none;
      }
      .navbar a {
      transition: color 0.5s ease-in;
      -webkit-transition: color 0.5s ease-in;
      }
      .navbar li a {
      font-weight: bold;
      }
      .navbar a {
      text-transform: uppercase
      }
      div.prompt {
      display: none;
      }
      div.thebe_controls {
      margin-top: 5px;
      margin-bottom: 20px;
      }
      div.thebe_controls button {
      background-color: #eaeaea;
      font-size: 1em;
      padding: 5px 20px;
      }
      div.kernel_controls {
      padding: 20px;
      background: rgba(200, 200, 200, 0.4);
      max-width: 600px;
      text-align: center;
      margin: 10px auto;
      }
      div.cell div.thebe_wrap div.input {
      border: 1px solid #c8c8c8;
      padding: 10px;
      }
    </style>

  </head>
  <body>
    <div class="container">
      <div class="row">
	<div class="col-md-8 col-md-offset-2">
	  <nav class="navbar navbar-default" role="navigation">
	    
	    <!-- Brand and toggle get grouped for better mobile display -->
	    <div class="navbar-header">
	      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
		<span class="sr-only">Toggle navigation</span>
		<span class="icon-bar"></span>
		<span class="icon-bar"></span>
		<span class="icon-bar"></span>
	      </button>
	      <a class="navbar-brand name" href="http://betatim.github.io/">Tim<b>Head</b></a>
	    </div>
	    <div class="collapse navbar-collapse navbar-right">
	      <ul class="nav navbar-nav">
		<!-- <li><a href="#">Notes</a></li> -->
		<!-- <li><a href="#">Talks</a></li> -->
                         <li><a href="/pages/about.html">
                             About
                         </a></li>
                         <li><a href="/pages/science.html">
                             Science
                         </a></li>
                         <li><a href="/pages/sports.html">
                             Sports
                         </a></li>
	      </ul>
	    </div>
	    
	  </nav>  
	</div>
      </div>
    </div>
    
    <div class="container">
      <div class="col-md-8 col-md-offset-2">
    <section id="content">
        <article>
            <header class="title">
                <h1>
                    <!--<a href="http://betatim.github.io/posts/genome-hackers/"
                       rel="bookmark"
                       title="Permalink to Genome Assembly for Hackers">
                        Genome Assembly for Hackers
                    </a>-->
		    Genome Assembly for Hackers
                </h1>
		<div class="when">09 June 2016</div>
            </header>
            <div class="entry-content">
                <p>
<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This post collects code snippets I created while learning about genome assembly.
I understand complicated things through code. I build simulations or little
tools and they help me immensely to understand how something works. Probably
because it uses vocabulary I am familiar with (python!) instead of domain
specific jargon.</p>
<p>For another great example of "understanding X through code" check out <a href="https://twitter.com/jakevdp">Jake VanderPlas'</a> talk <a href="https://speakerdeck.com/jakevdp/statistics-for-hackers">Statistics for hackers</a> (<a href="https://www.youtube.com/watch?v=-7I7MWTX0gA">video</a>).</p>
<p>This post covers the basic basics of "genome assembly". Starting with a genome,
creating "reads" from it, breaking these reads up into "kmers", and then
doing the actual assembly. There are a lot of subtleties that I gloss over,
ignored details and ouright shortcuts (hashtag-physics-style). Please biology
friends, don't hate me :)</p>
<p>I assume you have done some reading about this topic and came here to see it
translated into code. I link to various wikipedia articles through out, but
otherwise will not try and explain the biology reasoning behind all this (not just
because I don't know it myself ...).</p>
<p>Let's start with generating a random "genome".</p>

</div>
</div>
</div>
<pre data-executable>
import copy
import string
import random
from itertools import product
from collections import defaultdict

import numpy as np

random.seed(123)
np.random.seed(321)
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Genome">The Genome<a class="anchor-link" href="#The-Genome">&#182;</a></h2><p>We will use a fairly short genome made up totally at random. In reality
genomes have millions or billions of base pairs and contain structure.
Welcome to the world of <a href="https://en.wikipedia.org/wiki/Spherical_cow">"spherical cows in a vacuum"</a>.</p>

</div>
</div>
</div>
<pre data-executable>
genome = "".join(random.choice("AGCT") for _ in range(1000))
</pre>

<pre data-executable>
# this is a great genome, trust me
genome
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reading">Reading<a class="anchor-link" href="#Reading">&#182;</a></h2><p>To get the genome out of a cell you need to read it. This is called <a href="https://en.wikipedia.org/wiki/Sequencing">sequencing</a>. While there are many methods to do
this in an actual lab, in practice they all create "reads". These are short sections
of the genome that cover a random part of it. To start with let's assume we can
generate these reads without making any mistakes.</p>

</div>
</div>
</div>
<pre data-executable>
def perfect_reads(genome, n_reads=10):
    """Create perfect reads from `genome`"""
    starts = np.random.randint(len(genome), size=n_reads)
    length = np.random.randint(27,33, size=n_reads)
    for n in range(n_reads):
        low = starts[n]
        yield genome[low:low + length[n]]
</pre>

<pre data-executable>
list(perfect_reads(genome, 3))
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Reads can vary in size and come without information about where
in the genome they took place. You can end up with duplicate reads
of parts of reads overlapping. This is a good thing. These overlaps
is what will allow us to piece everything back together. Read more
about <a href="https://en.wikipedia.org/wiki/Shotgun_sequencing">Shotgun sequencing</a></p>
<p><em>NB:</em> Today most real world sequencing is done using <a href="https://en.wikipedia.org/wiki/Shotgun_sequencing#Whole_genome_shotgun_sequencing">"double barrel"
shotguns</a>. The key realisation is thhat you can create reads from both ends of
a fragment of the genome. This way you gain some information about the
direction of the reads relative to each other and how far they are apart.</p>
<p>Next each read is turned into a <a href="https://en.wikipedia.org/wiki/K-mer"><code>k-mer</code></a>.
These are what is used during the actual assembly. <code>k-mer</code>s are the substrings of
length <code>k</code> that you can generate from a string.</p>

</div>
</div>
</div>
<pre data-executable>
def kmers(read, k=10):
    """Generate `k`-mers from a `read`"""
    for n in range(len(read) - k + 1):
        yield read[n:n+k]
</pre>

<pre data-executable>
def get_perfect_kmers(genome):
    kmers_ = []
    for read in perfect_reads(genome, n_reads=1000):
        for kmer in kmers(read):
            kmers_.append(kmer)
            
    return kmers_
</pre>

<pre data-executable>
kmers_ = get_perfect_kmers(genome)
# lots of kmers, but not that many are unique
print(len(kmers_), len(set(kmers_)))
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With perfect reads from our random genome you end up with a
large number of <code>k-mers</code> (of length ten) but most of them
are duplicates. The roughly 20000 <code>k-mers</code> we created only
contain about 1000 unique <code>k-mers</code>.</p>
<h2 id="Flipping-reads">Flipping reads<a class="anchor-link" href="#Flipping-reads">&#182;</a></h2><p>In reality the sequencing process is not perfect and will
make mistakes. The simplest way to illustrate this is to
randomly flip a base in a read. Even fairly low error rates
of 1% per base have a large effect on the number of unique <code>k-mers</code>
we find.</p>

</div>
</div>
</div>
<pre data-executable>
def flip(read, p=0.01):
    """Flip a base to one of the other bases with probability `p`"""
    bases = []
    for b in read:
        if np.random.uniform() <= p:
            bases.append(random.choice("AGCT".replace(b, "")))
        else:
            bases.append(b)
    return "".join(bases)

def reads_with_errors(genome, n_reads=10):
    """Generate reads where bases might be flipped."""
    starts = np.random.randint(len(genome), size=n_reads)
    length = np.random.randint(27,33, size=n_reads)
    for n in range(n_reads):
        low = starts[n]
        yield flip(genome[low:low + length[n]])
</pre>

<pre data-executable>
def get_kmers(genome):
    kmers_ = []
    for read in reads_with_errors(genome, n_reads=1000):
        for kmer in kmers(read):
            kmers_.append(kmer)
            
    return kmers_

kmers_ = get_kmers(genome)
# roughly same number of kmers, but a lot more unique ones
print(len(kmers_), len(set(kmers_)))
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We still generate roughly 20000 <code>k-mers</code> but now there are
three times as many unique <code>k-mers</code>. This is one of the factors
that mkes assembling a genome so hard.</p>
<p>So now that we have a super simplistic model for generating
<code>k-mers</code>, how do we put them back together?</p>

</div>
</div>
</div>
<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Assembly">Assembly<a class="anchor-link" href="#Assembly">&#182;</a></h1><p>Left as an exercise for the reader.</p>
<p>Just kidding. Assembly happens by creating
a <a href="https://en.wikipedia.org/wiki/De_Bruijn_graph">de Bruijn graph</a>
from our <code>k-mers</code>. Importantly each <code>k-mer</code> is represented
by an <strong>edge</strong> in the graph, not a node! Nodes are for <code>k-1-mers</code>.
If we have one 4-mer, <code>abcd</code>, the graph would look like this: <code>abc -&gt; bcd</code>.
The first node represents the first <code>n-1</code> symbols in the <code>k-mer</code> and
the second node represents the last <code>n-1</code> symbols.</p>
<p>We will leave the world of biology behind for a moment and create
completely artificial examples. I found this easier to understand
and debug.</p>
<p>First we will need something that can turn a string into a graph.
Using <code>k=2</code> the <code>make_graph</code> function will do just that.</p>

</div>
</div>
</div>
<pre data-executable>
def make_graph(string, k):
    k_mers = list(kmers(string, k))
    nodes = defaultdict(list)

    for kmer in k_mers:
        head = kmer[:-1]
        tail = kmer[1:]
        nodes[head].append(tail)
        
    return nodes

nodes = make_graph('abcbdexdbfga', 2)
print(nodes)
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>nodes</code> is a dictionary mapping each node to the list
of outgoing edges for that node. Its printed representation
is quite ugly, so here is a graphical version of it:</p>
<p><img src="/images/euler-graph.png"/></p>
<p>You can render this with <code>graphviz</code> but this is not
installed on tmpbnb.org so will fail here.</p>

</div>
</div>
</div>
<pre data-executable>
from graphviz import Digraph

dot = Digraph(comment='debruijn')

for km1mer in nodes:
    dot.node(km1mer, km1mer)
    
for src in nodes:
    ends = nodes[src]
    for end in ends:
        dot.edge(src, end)

dot.format = 'png'
dot
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Eulerian-walks">Eulerian walks<a class="anchor-link" href="#Eulerian-walks">&#182;</a></h2><p>Why create this weird graph structure from our reads? At
first it seems like it makes things more complicated. Actually
this is an example of transforming your problem to make it
easier.</p>
<p>To reconstruct the original string from this graph all we
have to do is find a trip along all the edges of the graph
that visits each edge only once. If we can do that, we
are done. People who are into graph theory call this
an eulerian walk. If you grew up in Germany you might
recognise this as solving the <a href="https://de.wikipedia.org/wiki/Haus_vom_Nikolaus">kids puzzle</a> "Das ist das
Haus vom Ni-ko-laus."</p>
<p><a href="https://commons.wikimedia.org/wiki/File:Blender3D_HouseOfStNiclas.gif#/media/File:Blender3D_HouseOfStNiclas.gif"><img src="https://upload.wikimedia.org/wikipedia/commons/1/11/Blender3D_HouseOfStNiclas.gif" alt="Blender3D HouseOfStNiclas.gif"></a><br>Von <a href="//commons.wikimedia.org/wiki/User:SoylentGreen" title="User:SoylentGreen">SoylentGreen</a> - <span class="int-own-work" lang="de">Eigenes Werk</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=2308144</p><h2 id="Is-it-a-tour?">Is it a tour?<a class="anchor-link" href="#Is-it-a-tour?">&#182;</a></h2><p>First things first, how will we know if a proposed tour is
a valid one? This is what the next few functions take care
of.</p>

</div>
</div>
</div>
<pre data-executable>
def edges(graph):
    """List all directed edges of `graph`"""
    for node in graph:
        for target in graph[node]:
            yield (node, target)


def follow_tour(tour, graph):
    """Follow a tour and check it is eulerian"""
    edges_ = list(edges(graph))
    for start, end in zip(tour, tour[1:]):
        try:
            edges_.remove((start, end))
        # most likely removing an edge that was already used
        except:
            return False
        
    # if there are any edges left this is neither
    # an eulerian tour nor an eulerian trail
    if edges_:
        return False
    else:
        return True


def check_tour(start, graph):
    our_tour = tour(start, graph)
    valid_tour = follow_tour(our_tour, graph)
    return valid_tour, "".join(s[0] for s in our_tour) 
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To construct an actual eulerian cycle or trail we use
<a href="https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer.27s_algorithm">Hierholzer's algorithm</a>.</p>
<p>There are some subtleties we would have to take
care of for a production grade implementation, like
dealing with where to start when the graph only contains
an eulerian path and not a cycle, etc. However it
does the job for small examples and allows you to
witness the miracle of genome assembly!</p>

</div>
</div>
</div>
<pre data-executable>
def tour(start_node, graph):
    """Find an eulerian cycle or trail.
    
    This does not check if the graph is eulerian
    so it might return tours that are nonsense.
    """
    # _tour() modifies the graph structure so we need to copy it
    graph = copy.deepcopy(graph)
    return _tour(start_node, graph)

def _tour(start_node, graph, end=None):
    tour = [start_node]
    finish_on = end if end is not None else start_node
    while True:
        options = graph[tour[-1]]

        # eulerian trail, not tour?
        if not options:
            break
        
        tour.append(options.pop())
        if tour[-1] == finish_on:
            break
    
    # when we insert a sub-tour we extend the
    # length of tour, need to track this
    offset = 0
    for n,step in enumerate(tour[:]):
        options = graph[step]
        if options:
            t = _tour(options.pop(), graph, step)
            n += offset
            tour = tour[:n+1] + t + tour[n+1:]
            offset += len(t)
            
    return tour
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>below some examples of graphs I tried out while
writing the algorithm. This is an <a href="http://betatim.github.io/posts/interactive-posts/">interactive blog post</a>
so play around with them. Use the snippet form above to
draw each graph if you prefer to see it visually.</p>

</div>
</div>
</div>
<pre data-executable>
check_tour('a', {'a': ['b'], 'b': ['a']})
check_tour('a', {'a': ['b'], 'b': ['c'], 'c': ['a', 'e'], 'e': ['f'], 'f': ['c']})
check_tour('a', {'a': ['b'], 'b': ['c'], 'c': ['a', 'e'], 'e': ['f'],
                 'f': ['c', 'g'], 'g': ['f']})
check_tour('f', {'a': ['b'], 'b': ['c'], 'c': ['a', 'e'], 'e': ['f'],
                 'f': ['c', 'g'], 'g': ['f']})
check_tour('g', {'a': ['b'], 'b': ['c'], 'c': ['a', 'e'], 'e': ['f'],
                 'f': ['c', 'g'], 'g': ['f']})
check_tour('c', {'a': ['b'], 'b': ['c'], 'c': ['a', 'e'], 'e': ['f'],
                 'f': ['c', 'g'], 'g': ['f']})


random.seed(54)
genome = 'abcbdexdbfga'
g = make_graph(genome, 2)

valid, t = check_tour(genome[random.randint(0, len(genome)-1)], g)

print(g)
print(t)
</pre>

<div class="cellOOO border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I hope this helps you understand a bit more how all this genome assembly
stuff works. it certainly helped me. If you know about the biology behind
all this, please be lenient, if you spot gross mistakes or imprecise
statements that cause confusion for novices do get in touch!</p>
<p>If you find a mistake or want to tell me something else get in touch on twitter @<a href="//twitter.com/betatim">betatim</a></p>

</div>
</div>
</div></p>
<p>This post started life as a jupyter notebook,
<a href="/downloads/notebooks/genome-assembly.ipynb">download it</a>
or
<a href="http://nbviewer.ipython.org/url/betatim.github.io//downloads/notebooks/genome-assembly.ipynb">view it</a> online.</p>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

      </div>
    </div>

<div class="container">
  <div class="row">
    <div class="col-md-8 col-md-offset-2">
      <footer class="footer">
	<div class="social">
	    <a href="https://github.com/betatim"><i class="fa fa-github fa-2x"></i></a>
	    <a href="https://twitter.com/betatim"><i class="fa fa-twitter fa-2x"></i></a>
	    <a href="mailto:betatim@gmail.com"><i class="fa fa-envelope fa-2x"></i></a>
	</div>
	<div class="powered-by">
	  Copyright ©  2014-2016  - Tim Head - <a href="http://docs.getpelican.com/" target="_blank">Pelican</a> powered.
	</div>
      </footer>
    </div>
  </div>
</div>    
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/theme/js/bootstrap.min.js"></script>
  </body>
</html>